//作用：运用共享技术有效地支持大量细粒度的对象。

//分析：
//　　享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。
//  如果能发现这些实例数据除了几个参数外基本都是相同的。有时就能够大幅度地减少实例化的类的数量。
//  如果能把那些参数移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度地减少单个实例的数目。

//FlyweightFactory：
//
//1） 创建并管理Flyweight对象。
//2）确保合理地共享Flyweight。当用户请求一个Flyweight时，FlyweightFactory对象提供一个已创建的实例或者创建一个（如果不存在的话）
//
//Client
//1）维持一个对Flyweight的引用。
//2）计算或存储一个（多个）Flyweight的外部状态。
//
//
//分析：
//　　享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。
//  如果能发现这些实例数据除了几个参数外基本都是相同的。有时就能够大幅度地减少实例化的类的数量。
//  如果能把那些参数移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度地减少单个实例的数目。
//
//  　比如在文档编辑器的设计过程中，我们如果为每个字母创建一个对象的话，系统可能会因为大量的对象而造成存储开销的浪费。
//   例如一个字母“a”在文档中出现了10000次，而实际上我们可以让这一万个字母“a”共享一个对象，
//   当然因为在不同的位置可能字母“a”有不同的显示效果（例如字体和大小等设置不同），
//   在这种情况我们可以为将对象的状态分为“外部状态”和“内部状态”，将可以被共享（不会变化）的状态作为内部状态存储在对象中，
//   而外部对象（例如上面提到的字体、大小等）我们可以在适当的时候将外部对象做为参数传递给对象（例如在显示的时候，将字体、大小等信息传递给对象）。
//
//	Flyweight的内部状态是用来共享的，FlyweightFactory负责维护一个Flyweight池(存放内部状态的对象),
//  当客户端请求一个共享Flyweight时,这个FlyweightFactory首先搜索池中是否已经有可适用的,如果有,
//  FlyweightFactory只是简单返回这个对象,否则,创建一个新的对象,加入到池中,再返回这个对象.
//  池为重复或可共享的对象、属性设置一个缓冲，称为内部状态。这些内部状态一般情况下都是不可修改的，
//  也就是在第一个对象、属性被创建后，就不会去修改了(否则就没意义了)。
//  Flyweight 对对象的内部状态进行共享，只为每种内部状态创建一个实例,对内部状态使用了单例模式。
//
//	用户不应直接对ConcreteFlyweight类进行实例化，而只能从FlyweightFactory对象得到ConcreteFlyweight对象，
//	这可以保证对它们适当地进行共享。
//
//实现要点
//	1）享元工厂维护一张享元实例表。
//	2）享元不可共享的状态需要在外部维护。
//	   即删除外部状态：该模式的可用性在很大程度上取决于是否容易识别外部状态并将它从共享对象中删除。
//	3）按照需求可以对享元角色进行抽象。
//	4）管理共享对象：引用计数和垃圾回收……
//
//何时采用
//	1）如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用；
//	2）还有就是对象的大多数状态可变为外部状态，如果删除对象的外部状态，
//	   那么可以用相对较少的共享对象取代很多组对象，此时可以考虑所使用享元模式。
//	3）系统中有大量耗费了大量内存的细粒度对象，并且对外界来说这些对象没有任何差别的（或者说经过改造后可以是没有差别的）。
//
//	在文档编辑器例子中如果一个字符对应一个对象，那么一篇文档所要容纳的对象将是非常的庞大耗费大量的内存。
//	而实际组成文档的字符是有限的，是由这些字符不同的组合和排列得到的。所以需要共享，将基本的字符进行共享，
//	将使得字符对象变得有限。

#include "stdafx.h"
#include <iostream>
#include <stdlib.h>
#include "FlyweightFactory.h"
#include "Flyweight.h"

using namespace std;

int _tmain(int argc, _TCHAR* argv[])
{
	//外部状态extrinsicState
	string extrinsicState = "ext";

	//工厂对象，工厂对象
	FlyweightFactory* pFactory = new FlyweightFactory();

	//向工厂申请一个Flyweight对象，且该对象的内部状态值为“hello”
	Flyweight* fly = pFactory->GetFlyweight("hello");

	Flyweight* fly1 = pFactory->GetFlyweight("hello");

	//应用外部状态
	fly->Operator(extrinsicState);

	pFactory->GetFlyweightCount();

	delete pFactory;

	system("pause");
	return 0;
}

